---
title: "GLMMmodels"
author: "Kerri Miazgowicz"
date: "April 07, 2020"
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Part1: Daily bite rate GLMM fit and plot
Part2: Daily egg production GLMM fit and plot

Loading the required packages and the full dataset
```{r}
#Updated April 13,2020
# Set working directory
mainDir = "C:/Users/Kerri/Desktop/Chapter1 Submission"
setwd(mainDir)

library(car)
library(LMERConvenienceFunctions)
library(MASS)
library(arm)
library(sjPlot)
library(tidyr)
library(dplyr)
library(ggplot2)
library(lme4)
library(multcomp)
library(MuMIn)


##Load the full dataset
data <- read.csv("data//constant_master.csv")

##Conversion of Date to first a character, so that it can be converted to as Posix for comparative use
data$Date <-as.character(data$Date)
data$Date2 <-as.POSIXlt(data$Date, format="%m/%d/%Y")

##Ordering the dataframe by date, not needed, but is helpful when looking through the sheet.
data <- data[order(data$Date2),]

```

##########################################################
#************************************************************
#################DAILY BITE RATE##################
#**************************************************************
##########################################################


Organizing the raw data to be used for bite rate
```{r }
#Create a dataset that is specific to the feed data - removing all rows where there is no DV present
feeddata <- subset(data, select = c("Treatment", "Block", "Donor", "Female", "Feed", "Day"))
feeddata <- feeddata %>% drop_na(Feed)

#Following Greg's code, making Temperature a continuous variable

#feeddata$Treatment <- as.factor(feeddata$Treatment)
feeddata$Block <- as.factor(feeddata$Block)
feeddata$Donor <- as.factor(feeddata$Donor)
feeddata$Female <- as.factor(feeddata$Female)

#Centering and scaling continuous variables of interest (Treatment, Day)
feeddata$Tscale <- scale(feeddata$Treatment)
feeddata$Dscale <- scale(feeddata$Day)
```


looking at bite rate as *Number of bites taken on day x divided by the number of females alive on day x
The response variable we reported that we measured 'The porportion of mosquitoes imbibing blood on a given day'
Associated with Figure 1a
```{r}

testdata <- feeddata %>%
            dplyr::group_by(Treatment,Block,Day,Donor) %>%
            dplyr::summarise( bites = sum(Feed),
                              opport = dplyr::n(),
                              bite.rate  = (bites/opport))%>%
            ungroup()

testdata$Block <- as.factor(testdata$Block)
testdata$Donor <- as.factor(testdata$Donor)

#Centering and scaling continuous variables of interest (Treatment, Day)
testdata$Tscale <- scale(testdata$Treatment)
testdata$Dscale <- scale(testdata$Day)

############################################################################3
##################ADDRESSING REVIEWER #2 
#Truncate dataset to past day 4 and rerun analysis
testdata.trunc <- subset(testdata[testdata$Day>4,])


#formula is either direct porportion, weight = trials or cbind (success , failures)
m1.t <- glmer(cbind(bites,opport-bites)~ Tscale + (1|Block), family = binomial, data = testdata.trunc)
m2.t <- glmer(cbind(bites,opport-bites) ~ Dscale + (1|Block), family = binomial, data = testdata.trunc)
m3.t <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale + (1|Block), family = binomial, data = testdata.trunc)
m4.t <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale + (1|Block) + (1|Donor), family = binomial, data = testdata.trunc)
m5.t <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale + (1|Block), family = binomial, data = testdata.trunc)
m6.t <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale + (1|Donor), family = binomial, data = testdata.trunc)
m7.t <- glm(cbind(bites,opport-bites) ~ Tscale, family = binomial, data = testdata.trunc)
m8.t <- glm(cbind(bites,opport-bites) ~  Dscale, family = binomial, data = testdata.trunc)
m9.t <- glm(cbind(bites,opport-bites) ~ Tscale + Dscale, family = binomial, data = testdata.trunc)
m10.t <- glm(cbind(bites,opport-bites) ~ Tscale * Dscale, family = binomial, data = testdata.trunc)

#add in nonlinear terms
m11.t <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale +I(Dscale^2)+ (1|Donor), family = binomial, data = testdata.trunc)
m12.t <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale +I(Dscale^2)+ I(Tscale^2)+ (1|Donor), family = binomial, data = testdata.trunc)#m12 is the best for the truncated data
m13.t <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale +I(Dscale^3)+ I(Tscale^2)+ (1|Donor), family = binomial, data = testdata.trunc)
#checking how these fit the truncated dataset
m14.t<-glmer(cbind(bites,opport-bites) ~ Tscale * Dscale +I(Dscale^3)+(1|Donor), family = binomial, data = testdata.trunc)
m15.t<- glmer(cbind(bites,opport-bites) ~ Tscale * I(Dscale^3)+Dscale +(1|Donor), family = binomial, data = testdata.trunc)
m16.t<- glmer(cbind(bites,opport-bites) ~ Tscale * I(Dscale^4)+Dscale +(1|Donor), family = binomial, data = testdata.trunc)
m17.t<- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale + I(Dscale^4)+(1|Donor), family = binomial, data = testdata.trunc)
m18.t<- glmer(cbind(bites,opport-bites) ~ Tscale * I(Dscale^3)+Dscale+ I(Tscale^2) +(1|Donor), family = binomial, data = testdata.trunc)
m19.t <- glmer(cbind(bites,opport-bites) ~ I(Tscale^2) * I(Dscale^3)+Dscale+ Tscale +(1|Donor), family = binomial, data = testdata.trunc)
m20.t <- glmer(cbind(bites,opport-bites) ~ I(Tscale^2) * I(Dscale^3)+(1|Donor), family = binomial, data = testdata.trunc)
m21.t <- glmer(cbind(bites,opport-bites) ~ I(Tscale^2) * I(Dscale^3)+Dscale +(1|Donor), family = binomial, data = testdata.trunc)
m22.t <- glmer(cbind(bites,opport-bites) ~ I(Tscale^2) * I(Dscale^3)+Tscale +(1|Donor), family = binomial, data = testdata.trunc)


modlist.trun <- list(m1.t,m2.t,m3.t,m4.t,m5.t,m6.t,m7.t,m8.t,m9.t,m10.t,m11.t,m12.t,m13.t,m14.t,m15.t,m16.t,m17.t,m18.t,m19.t,m20.t,m21.t,m22.t)
selection.table.trun <- model.sel(modlist.trun) #model 12 fits the truncated data better. 
#supports the use of the 3order term with the full data?

summary(m12.t)
Anova(m12.t) #With truncated data day becomes significant

###Make predictions and plot
testdata.trunc$Pred.respon <- NA
testdata.trunc$Pred.link <- NA

#I need to predict over a dataframe that have scaled values for Tscale and Dscale
testdata.trunc$Pred.respon <- predict(m12.t , testdata.trunc, re.form=NA, type="response")
testdata.trunc$Pred.link  <- predict(m12.t , testdata.trunc, re.form=NA, type="link")

#Plot of the predictions to the proportion of females imbibing blood - truncated dataset
ggplot(data= testdata.trunc, aes(x=Day, y= (bites/opport), colour = factor(Treatment), group = factor(Treatment), linetype = factor(Treatment))) + 
  scale_colour_manual(values= c("#88498F","#1C77C3", "#3B3B3E","#26AE11","#FF6B35","#CC0606")) +
  geom_point(aes( color= factor(Treatment)), size = 2, shape = 0) + 
  geom_point(aes(color = factor(Treatment), y = Pred.respon), shape = 16, size = 2)+
  #geom_line(data = bite.day.summary, aes( y= BFD2), linetype = "solid", size = 1.2, alpha = 0.3) +
  scale_x_continuous(name="Days at treatment", limits = c (0, 60), breaks = seq(0,60,5), expand = c(0.01,0)) +
  # geom_smooth(aes(y = (bites/opport), fill = factor(Treatment)), method = "loess",linetype = "solid", se = FALSE, size = 1.5 )  +
  scale_y_continuous(name="Biting probability", limits=c(0, 1), breaks = seq(0,1,.1), expand = c(0.01,0)) +
  theme_bw(base_size = 16) +
  theme(legend.position = c (.75,.9)) +
  guides(col =guide_legend(nrow = 1)) 

#Export these figures for review justification

##############################################################3
##########################Full dataset analysis#########################3
#formula is either direct porportion, weight = trials or cbind (success , failures)
m1 <- glmer(cbind(bites,opport-bites)~ Tscale + (1|Block), family = binomial, data = testdata)
m2 <- glmer(cbind(bites,opport-bites) ~ Dscale + (1|Block), family = binomial, data = testdata)
m3 <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale + (1|Block), family = binomial, data = testdata)
m4 <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale + (1|Block) + (1|Donor), family = binomial, data = testdata)
m5 <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale + (1|Block), family = binomial, data = testdata)
m6 <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale + (1|Donor), family = binomial, data = testdata)
m7 <- glm(cbind(bites,opport-bites) ~ Tscale, family = binomial, data = testdata)
m8 <- glm(cbind(bites,opport-bites) ~  Dscale, family = binomial, data = testdata)
m9 <- glm(cbind(bites,opport-bites) ~ Tscale + Dscale, family = binomial, data = testdata)
m10 <- glm(cbind(bites,opport-bites) ~ Tscale * Dscale, family = binomial, data = testdata)

#add in nonlinear terms
m11 <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale +I(Dscale^2)+ (1|Donor), family = binomial, data = testdata)
m12 <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale +I(Dscale^2)+ I(Tscale^2)+(1|Donor), family = binomial, data = testdata)
#since it does seem the first few days of data are influencing the model predictions, seeing if a 3rd order poly is more appropiate
m13 <- glmer(cbind(bites,opport-bites) ~ Tscale * Dscale +I(Dscale^3)+ I(Tscale^2)+(1|Donor), family = binomial, data = testdata)
m14<-glmer(cbind(bites,opport-bites) ~ Tscale * Dscale +I(Dscale^3)+(1|Donor), family = binomial, data = testdata)
m15<- glmer(cbind(bites,opport-bites) ~ Tscale * I(Dscale^3)+Dscale +(1|Donor), family = binomial, data = testdata)
m16<- glmer(cbind(bites,opport-bites) ~ Tscale * I(Dscale^3)+Dscale+ I(Tscale^2) +(1|Donor), family = binomial, data = testdata)
m17 <- glmer(cbind(bites,opport-bites) ~ I(Tscale^2) * I(Dscale^3)+Dscale+ Tscale +(1|Donor), family = binomial, data = testdata)
m18 <- glmer(cbind(bites,opport-bites) ~ I(Tscale^2) * I(Dscale^3)+(1|Donor), family = binomial, data = testdata)
m19 <- glmer(cbind(bites,opport-bites) ~ I(Tscale^2) * I(Dscale^3)+Dscale +(1|Donor), family = binomial, data = testdata)
m20 <- glmer(cbind(bites,opport-bites) ~ I(Tscale^2) * I(Dscale^3)+Tscale +(1|Donor), family = binomial, data = testdata)

modlist.full.feed <- list(m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,m13,m14,m15,m16,m17,m18,m19,m20)
selection.table.full.feed <- model.sel(modlist.full.feed)
#Model 17 is the best, followed by Model 13

#pairwise comparisons not valid due to the interaction term. 
summary(m17)
Anova(m17)

testdata$Pred.respon <- NA
testdata$Pred.link <- NA

#I need to predict over a dataframe that have scaled values for Tscale and Dscale
testdata$Pred.respon <- predict(m17 , testdata, re.form=NA, type="response")
testdata$Pred.link  <- predict(m17, testdata, re.form=NA, type="link")

test.predictions.only <- testdata[c("Tscale","Dscale","Pred.respon","Pred.link")]
#Unscale Tscale and Dscale for easy of plotting predicted values;
test.predictions.only$Treatment <- test.predictions.only$Tscale * attr(test.predictions.only$Tscale, 'scaled:scale') + attr(test.predictions.only$Tscale, 'scaled:center')
test.predictions.only$Day <- as.numeric(test.predictions.only$Dscale * attr(test.predictions.only$Dscale, 'scaled:scale') + attr(test.predictions.only$Dscale, 'scaled:center'))

#Eliminate duplicate values- (Ie population values, not individual)
test.predictions.test <- dplyr::distinct(test.predictions.only, Treatment, Day ,.keep_all = TRUE)
test.predictions.test$Pred.respon <- round(test.predictions.test$Pred.respon, 5)

test.predictions.test$Treatment <- as.factor(test.predictions.test$Treatment)

#Plot of the predictions to the proportion of females imbibing blood - full dataset
ggplot(data= testdata, aes(x=Day, y= (bites/opport), colour = factor(Treatment), group = factor(Treatment), linetype = factor(Treatment))) + 
  scale_colour_manual(values= c("#88498F","#1C77C3", "#3B3B3E","#26AE11","#FF6B35","#CC0606")) +
  geom_point(aes( color= factor(Treatment)), size = 2, shape = 0) + 
  geom_point(aes(color = factor(Treatment), y = Pred.respon),shape = 16, size = 2)+
  scale_x_continuous(name="Days at treatment", limits = c (0, 60), breaks = seq(0,60,5), expand = c(0.01,0)) +
  scale_y_continuous(name="Biting probability", limits=c(0, 1), breaks = seq(0,1,.1), expand = c(0.01,0)) +
  theme_bw(base_size = 16) +
  theme(legend.position = c (.75,.9)) +
  guides(col =guide_legend(nrow = 1)) 


```



To add in the raw data to the graph I first have to create a Day-specific average bite rate from the raw data for each Temperature (with SEM) to be able to look at the accuracy of the predictions.
```{r}
#Keep all 0
raw.bite <- feeddata[,c("Treatment", "Block", "Female", "Feed", "Day")]
raw.bite <- na.omit(raw.bite)

#Generate day averages of number of bites over number of females alive on day x, grouped by Treatment 
day.summary <- summarise(group_by(raw.bite, Treatment, Block, Day), bite.day = sum(Feed), alive.day = n(), BFD = (bite.day/alive.day))

#For the day-specific VC figure I will be calculated the data specific bite rate for each block. However 'Block 2' will be REPLICATE #1, 'Blocks 3,5" are REPLICATE #2", Whereas 'Block 4' is the Replicate 3 for the 28C treatment only.
#subsetting the 'raw.bite DF into the above specifications
rep.1.data <- raw.bite[which(raw.bite$Block == 2),]
rep.2.data <- raw.bite[which((raw.bite$Block == 3 | raw.bite$Block == 5)),]
rep.3.data <- raw.bite[which(raw.bite$Block == 4),]

#Calulating the day.summary for bite rate for each replication
rep.1.bite.sum <- summarise(group_by(rep.1.data, Treatment, Day), bite.day = sum(Feed), alive.day = n(), BFD = (bite.day/alive.day))
rep.2.bite.sum <- summarise(group_by(rep.2.data, Treatment, Day), bite.day = sum(Feed), alive.day = n(), BFD = (bite.day/alive.day))
rep.3.bite.sum <- summarise(group_by(rep.3.data, Treatment, Day), bite.day = sum(Feed), alive.day = n(), BFD = (bite.day/alive.day))

#export rep specific bite rate data for use in excel
#write.csv(rep.1.bite.sum, "rep1.biterate.csv")
#write.csv(rep.2.bite.sum, "rep2.biterate.csv")
#write.csv(rep.3.bite.sum, "rep3.biterate.csv")

#Generate replicate-specific averages for bite rate with SEM
rep.1.ave.bite <-  summarise(group_by(rep.1.bite.sum, Treatment), BITE = mean(BFD), SEM = sd(BFD)/sqrt(length(BFD)))
rep.2.ave.bite <-  summarise(group_by(rep.2.bite.sum, Treatment), BITE = mean(BFD), SEM = sd(BFD)/sqrt(length(BFD)))
rep.3.ave.bite <-  summarise(group_by(rep.3.bite.sum, Treatment), BITE = mean(BFD), SEM = sd(BFD)/sqrt(length(BFD)))

#Export rep speicifc EFD averages for use in excel
#write.csv(rep.1.ave.bite, "rep1.ave.a.csv")
#write.csv(rep.2.ave.bite, "rep2.ave.a.csv")
#write.csv(rep.3.ave.bite, "rep3.ave.a.csv")


#####
#Note this is generating the SEM of the bite rate between the means of the replicates (n=2)
#####
bite.day.summary <- summarise(group_by(day.summary, Treatment, Day), BFD2 = mean(BFD), SEM = sd(BFD)/ sqrt(length(BFD)), SD = sd(BFD))

bite.treatment.summary <- summarise(group_by(day.summary, Treatment), BFD2 = mean(BFD), SEM = sd(BFD)/sqrt(length(BFD)), SD = sd(BFD))
```

###RAW data Bite rate, with both replicates
-highlighting the individual variation from each replicate (Block)-
To create a new cleaner final figure of the bite rate using the raw data I will;
2. Plot these two averages for each block - no error & with error
3. Plot fitted model predictions m12 
```{r echo= FALSE }
#By day - with predictions overlaid
day.summary$Treatment <- as.factor(day.summary$Treatment)

feed.all <- as.data.frame(merge(bite.day.summary, test.predictions.only, by = c("Treatment", "Day")))
feed.all$Treatment <- as.factor(feed.all$Treatment)

#For supplemental to address reviewer #2 -> raw data over GLMM predictions instead of loess
a<- ggplot(data= day.summary, aes(x=Day, colour = factor(Treatment), group = factor(Treatment))) + 
        scale_colour_manual(values= c("#88498F","#1C77C3", "#4C4C4F","#196F0B","#FF6B35","#CC0606")) +
        scale_fill_manual(values= c("#88498F","#1C77C3", "#4C4C4F","#196F0B","#FF6B35","#CC0606")) +
        geom_point(aes(y = BFD), shape = 16, size = 1.5, alpha = .6, stroke =1.2, fill = NA) + 
        scale_x_continuous(name="Days at treatment", limits = c (0, 60), breaks = seq(0,60,5), expand = c(0.02,0.02)) +
        scale_y_continuous(name="Prop. females that imbibed blood", limits=c(0, 1), breaks = seq(0,1,0.1), expand = c(0.02,0.02)) +
        geom_line(data = feed.all, aes(y = Pred.respon), linetype = "solid", size = 1.2) +
       geom_line(data = bite.day.summary, aes( y= BFD2), linetype = "solid", size = 1.2, alpha = 0.5) +
        theme_classic( base_size = 16) +
        theme(legend.position = 'none', panel.border = element_rect(colour = "black", fill=NA, size=.5),  panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), panel.background = element_blank(), strip.background = element_blank(), strip.text = element_blank())

plot(a)
#a.test <-a + facet_grid(Treatment ~ .)
#plot(a.test)
```


```{r}
#For supplemental to address reviewer #2 -> loess curves next to GLMM predictions
#I don't actually need this figure if I change it
b<- ggplot(data= day.summary, aes(x=Day, colour = factor(Treatment), group = factor(Treatment))) + 
        scale_colour_manual(values= c("#88498F","#1C77C3", "#4C4C4F","#196F0B","#FF6B35","#CC0606")) +
        scale_fill_manual(values= c("#88498F","#1C77C3", "#4C4C4F","#196F0B","#FF6B35","#CC0606")) +
       # geom_point(aes(y = BFD), shape = 16, size = 1.5, alpha = .6, stroke =1.2, fill = NA) + 
        scale_x_continuous(name="Days at treatment", limits = c (0, 60), breaks = seq(0,60,5), expand = c(0.02,0.02)) +
        scale_y_continuous(name="Prop. females imbibed blood", limits=c(0, 1), breaks = seq(0,1,0.1), expand = c(0.02,0.02)) +
        geom_smooth(aes(y = BFD, fill = factor(Treatment)), method = "loess",linetype = "dashed", se = FALSE, size = 1.5 )  +
        geom_line(data = feed.all, aes(y = Pred.respon), linetype = "solid", size = 1.2) +
       geom_line(data = bite.day.summary, aes( y= BFD2), linetype = "solid", size = 1.2, alpha = 0.3) +
        theme_classic( base_size = 16) +
        theme(legend.position = 'none', panel.border = element_rect(colour = "black", fill=NA, size=.5),  panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), panel.background = element_blank(), strip.background = element_blank(), strip.text = element_blank())

plot(b)


library(ggpubr)
SI.biterate.reviewer2 <- ggarrange(a, b, ncol = 2, nrow = 2, labels = c("a", "b"),font.label = list(size =16),common.legend = TRUE, legend = "bottom")

#ggsave("SI.biterate.loessover.reviewer2.modelfit.png", SI.biterate.reviewer2, path = NULL, scale = 1, width = 10, height = 5, device = 'png', dpi = 500)
```

####Figure 1a: In the Manuscript
```{r}
#By day - aspects included
#1. block-specific day average of the raw data (points)
#2. overall day summary of the raw data (faded lines)
#3. Best fitting glm model predictions (dashed lines)  -"test.predictions.test" df

bite.day.summary$Treatment <- as.factor(bite.day.summary$Treatment)

bite.day.plot <- ggplot(data= day.summary, aes(x=Day, colour = factor(Treatment), group = factor(Treatment))) + 
        scale_colour_manual(values= c("#88498F","#1C77C3", "#4C4C4F","#196F0B","#FF6B35","#CC0606")) +
        scale_fill_manual(values= c("#88498F","#1C77C3", "#4C4C4F","#196F0B","#FF6B35","#CC0606")) +
        geom_point(aes(y = BFD), shape = 16, size = 1.5, alpha = .6, stroke =1.2, fill = NA) + 
        scale_x_continuous(name="Days at temperature", limits = c (0, 60), breaks = seq(0,60,10), expand = c(0.02,0.02)) +
        scale_y_continuous(name="Proportion imbibed blood", limits=c(0, 1), breaks = seq(0,1,0.5), expand = c(0.02,0.02)) +
        geom_line(data = bite.day.summary, aes( y= BFD2), linetype = "solid", size = 1.2, alpha = 0.4) +
        geom_line(data = test.predictions.test, aes(y = Pred.respon, x = Day), linetype = "solid", size = 1.5 )+
        theme_classic( base_size = 20) +
        theme(legend.position = 'none', panel.border = element_rect(colour = "black", fill=NA, size=.5),  panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), panel.background = element_blank(), strip.background = element_blank(), strip.text = element_blank())

plot(bite.day.plot)
bite.day.plot + facet_grid(Treatment ~ .)
summary(m19)
Anova(m19)

##################Figure for response to reviewer#2; Overlay the best fitting model predictions for the truncated dataset (from day 5 on); best fitting model predictions for the full dataset; on the raw data (block means )

bite.reviewer2 <- ggplot(data= day.summary, aes(x=Day, colour = factor(Treatment), group = factor(Treatment))) + 
        scale_colour_manual(values= c("#88498F","#1C77C3", "#4C4C4F","#196F0B","#FF6B35","#CC0606")) +
        scale_fill_manual(values= c("#88498F","#1C77C3", "#4C4C4F","#196F0B","#FF6B35","#CC0606")) +
        #geom_point(aes(y = BFD), shape = 16, size = 1.5, alpha = .6, stroke =1.2, fill = NA) + 
        scale_x_continuous(name="Days at temperature", limits = c (0, 60), breaks = seq(0,60,10), expand = c(0.02,0.02)) +
        scale_y_continuous(name="Proportion imbibed blood", limits=c(0, 1), breaks = seq(0,1,0.5), expand = c(0.02,0.02)) +
        geom_line(data = bite.day.summary, aes( y= BFD2), linetype = "solid", size = 1.2, alpha = 0.4) +
        geom_line(data = test.predictions.test, aes(y = Pred.respon, x = Day), linetype = "solid", size = 1.2 )+
         geom_line(data = testdata.trunc, aes(y = Pred.respon, x = Day), linetype = "dotted", size = 2.0 )+
        theme_classic( base_size = 20) +
        theme(legend.position = 'none', panel.border = element_rect(colour = "black", fill=NA, size=.5),  panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), panel.background = element_blank(), strip.background = element_blank(), strip.text = element_blank())


bite.GLMM.reviewer2 <- bite.reviewer2 + facet_grid(Treatment ~ .)
plot(bite.GLMM.reviewer2)
```




##########################################################
#************************************************************
#################DAILY EGG PRODUCTION##################
#**************************************************************
##########################################################

### 2. Generating models related to fecundity (aka.reproducive output) by first making a dataset specific to Eggs per female per day at each day of experiment (EFD)

```{r }
#Create a dataset that is specific to the egg data
all.eggs <- subset(data, select = c("Treatment", "Block","Donor", "Female", "Laid","Count", "Day"))

all.eggs$Count[which(is.na(all.eggs$Count == "NA"))] <- 0
all.eggs <- na.omit(all.eggs)

#This is EFD defined as eggs laid on day X divided by the number of females alive on day X
EFD.day <- summarise(group_by(all.eggs, Day, Treatment, Block, Donor), EFD = sum(Count)/length(Female))


#Need to round EFD to have finite values
EFD.day$EFD <- round(EFD.day$EFD, digits = 5)
EFD.day$EFD.t <- EFD.day$EFD + .01
```

Model selection to EFD (defined as a day-specific value) and Lifetime egg production

```{r}
#Make sure that all of variables are defined correctly
library(fitdistrplus)

EFD.day$Block <- as.factor(EFD.day$Block)
EFD.day$Donor <- as.factor(EFD.day$Donor)

#Centering and scaling continuous variables of interest (Treatment, Day)
EFD.day$Tscale <- scale(EFD.day$Treatment)
EFD.day$Dscale <- scale(EFD.day$Day)


#Looking at my data distribution
hist(EFD.day$EFD, breaks=50, col="red")

#Since the shape of the hist is influenced by the num of bins, Kernel Density Plot is better
d <- density(EFD.day$EFD) # returns the density data 
plot(d)

#Assesses the use of a gamma distributon on these data
fit.gamma <- fitdist(EFD.day$EFD.t, distr = "gamma", method = "mme") #gamma fits fine
fit.lognormal <- fitdist(EFD.day$EFD.t, distr = "lnorm", method = "mme")

plot(fit.gamma)
plot(fit.lognormal)

#Determining the best distribution

descdist(EFD.day$EFD, discrete = FALSE)

qqp(EFD.day$EFD.t, "norm")
qqp(EFD.day$EFD.t, "lnorm")
qqp(EFD.day$EFD.t, "exp")
#qqp(EFD.day$EFD.t, "gamma", shape = gamma$estimate[[1]], rate = gamma$estimate[[2]])

EFD.m1 <- glmer(EFD.t ~ Dscale * Tscale + (1|Block) + (1|Donor), family = Gamma(link='log'), data = EFD.day)
EFD.m2 <- glmer(EFD.t ~ Tscale + (1|Block), family = Gamma(link = 'log'), data = EFD.day)
EFD.m3 <- glmer(EFD.t ~ Dscale + (1|Block), family = Gamma(link = 'log'), data = EFD.day)
EFD.m4 <- glmer(EFD.t ~ Tscale * Dscale + (1|Block), family = Gamma(link = 'log'), data = EFD.day)
EFD.m5 <- glmer(EFD.t ~ Tscale * Dscale + (1|Donor), family = Gamma(link = 'log'), data = EFD.day)
EFD.m6 <- glmer(EFD.t ~ Tscale + (1|Donor), family = Gamma(link = 'log'), data = EFD.day)
EFD.m7 <- glmer(EFD.t ~ Dscale + (1|Donor), family = Gamma(link = 'log'), data = EFD.day)

#Try a few nonlinear fits.....
EFD.m8 <-glmer(EFD.t ~ Dscale + Tscale + (1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m9 <-glmer(EFD.t ~ Dscale*Tscale + (1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m10 <-glmer(EFD.t ~ Dscale + I(Dscale^2) + Tscale + (1|Donor),	data = EFD.day, family = Gamma(link = 'log'))
EFD.m11<-glmer(EFD.t ~ Tscale + I(Tscale^2) + Dscale + (1|Donor),	data = EFD.day, family = Gamma(link = 'log'))
EFD.m12<-glmer(EFD.t ~ Tscale + I(Tscale^2) + Dscale + I(Dscale^2) + (1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m13<-glmer(EFD.t ~ Tscale*Dscale + I(Dscale^2)*I(Tscale^2) + (1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m14<-glmer(EFD.t ~ Tscale*Dscale + I(Dscale^2) + (1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m15<-glmer(EFD.t ~ Tscale*Dscale + I(Tscale^2) + (1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m16<-glmer(EFD.t ~ Dscale + I(Dscale^3) + Tscale + (1|Donor),	data = EFD.day, family = Gamma(link = 'log'))
EFD.m17<-glmer(EFD.t ~ Tscale + I(Dscale^2) + Dscale + (1|Donor),	data = EFD.day, family = Gamma(link = 'log'))
EFD.m18<- glmer(EFD.t ~ Tscale* Dscale + I(Dscale^2) + (1|Donor),	data = EFD.day, family = Gamma(link = 'log'))
EFD.m19 <-glmer(EFD.t ~ Tscale*Dscale + I(Dscale^2)+ I(Tscale^2) + (1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m20 <-glmer(EFD.t ~ Tscale*Dscale + I(Dscale^3)+ I(Tscale^2) + (1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m21 <-glmer(EFD.t ~ I(Dscale^3)* I(Tscale^2)+Tscale+Dscale +  + (1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m22 <- glmer(EFD.t ~  I(Dscale^2)* I(Tscale^2) + Tscale+Dscale+(1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m23 <- glmer(EFD.t ~  I(Dscale^2)* I(Tscale^2)+(1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m24 <-glmer(EFD.t ~ Tscale * I(Dscale^2)+ I(Tscale^2) + Dscale+ (1|Donor), data = EFD.day, family = Gamma(link = 'log'))

modlist.EFD <- list(EFD.m1, EFD.m2, EFD.m3, EFD.m4, EFD.m5, EFD.m6, EFD.m7,EFD.m8,EFD.m9,EFD.m10,EFD.m11,EFD.m12,EFD.m13,EFD.m14,EFD.m15,EFD.m16,EFD.m17,EFD.m18,EFD.m19,EFD.m20,EFD.m21,EFD.m22,EFD.m23,EFD.m24)
selection.table.EFD <- model.sel(modlist.EFD)
#Top model = 19 with nonlinear terms
summary(EFD.m19)
Anova(EFD.m19)

```

Since mosquitoes don't lay eggs for three days would the best fitting model change if I fit to truncated data...past day 3

```{r}
#Truncate dataset to past day 2 and rerun analysis
EFD.data.trun <- subset(EFD.day[EFD.day$Day>2,])

EFD.m1.t <- glmer(EFD.t ~ Dscale * Tscale + (1|Block) + (1|Donor), family = Gamma(link='log'), data = EFD.data.trun)
EFD.m2.t <- glmer(EFD.t ~ Tscale + (1|Block), family = Gamma(link = 'log'), data = EFD.data.trun)
EFD.m3.t <- glmer(EFD.t ~ Dscale + (1|Block), family = Gamma(link = 'log'), data = EFD.data.trun)
EFD.m4.t <- glmer(EFD.t ~ Tscale * Dscale + (1|Block), family = Gamma(link = 'log'), data = EFD.data.trun)
EFD.m5.t <- glmer(EFD.t ~ Tscale * Dscale + (1|Donor), family = Gamma(link = 'log'), data = EFD.data.trun)
EFD.m6.t <- glmer(EFD.t ~ Tscale + (1|Donor), family = Gamma(link = 'log'), data = EFD.data.trun)
EFD.m7.t <- glmer(EFD.t ~ Dscale + (1|Donor), family = Gamma(link = 'log'), data = EFD.data.trun)

#Try a few nonlinear fits.....
EFD.m8.t <-glmer(EFD.t ~ Dscale + Tscale + (1|Donor), data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m9.t <-glmer(EFD.t ~ Dscale*Tscale + (1|Donor), data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m10.t <-glmer(EFD.t ~ Dscale + I(Dscale^2) + Tscale + (1|Donor),	data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m11.t <-glmer(EFD.t ~ Tscale + I(Tscale^2) + Dscale + (1|Donor),	data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m12.t <-glmer(EFD.t ~ Tscale + I(Tscale^2) + Dscale + I(Dscale^2) + (1|Donor), data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m13.t <-glmer(EFD.t ~ Tscale*Dscale + I(Dscale^2)*I(Tscale^2) + (1|Donor), data = EFD.data.trun, family = Gamma(link = 'log')) #best one out of 23
EFD.m14.t <-glmer(EFD.t ~ Tscale*Dscale + I(Dscale^2) + (1|Donor), data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m15.t <-glmer(EFD.t ~ Tscale*Dscale + I(Tscale^2) + (1|Donor), data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m16.t <-glmer(EFD.t ~ Tscale*Dscale + I(Dscale^3)*I(Tscale^3) + (1|Donor), data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m17.t <-glmer(EFD.t ~ Dscale + I(Dscale^3) + Tscale + (1|Donor),	data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m18.t  <-glmer(EFD.t ~ Tscale + I(Tscale^3) + Dscale + (1|Donor),	data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m19.t <-glmer(EFD.t ~ Tscale + I(Dscale^2) + Dscale + (1|Donor),	data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m20.t <- glmer(EFD.t ~ Tscale* Dscale + I(Dscale^2) + (1|Donor),	data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m21.t <-glmer(EFD.t ~ Tscale*Dscale + I(Dscale^2)+ I(Tscale^2) + (1|Donor), data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m22.t <-glmer(EFD.t ~ Tscale*Dscale + I(Dscale^3)+ I(Tscale^2) + (1|Donor), data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m23.t  <-glmer(EFD.t ~ Tscale*I(Dscale^2)+ I(Tscale^2) + (1|Donor), data = EFD.data.trun, family = Gamma(link = 'log'))
EFD.m24.t <-glmer(EFD.t ~ Tscale*Dscale + I(Dscale^3)+ I(Tscale^2) + (1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m25.t <-glmer(EFD.t ~ I(Dscale^3)* I(Tscale^2)+Tscale+Dscale +  + (1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m26.t <- glmer(EFD.t ~  I(Dscale^2)* I(Tscale^2) + Tscale+Dscale+(1|Donor), data = EFD.day, family = Gamma(link = 'log'))
EFD.m27.t <- glmer(EFD.t ~  I(Dscale^2)* I(Tscale^2)+(1|Donor), data = EFD.day, family = Gamma(link = 'log'))


modlist.EFD.trun <- list(EFD.m1.t, EFD.m2.t, EFD.m3.t, EFD.m4.t, EFD.m5.t, EFD.m6.t, EFD.m7.t,EFD.m8.t,EFD.m9.t,EFD.m10.t,EFD.m11.t,EFD.m12.t,EFD.m13.t,EFD.m14.t,EFD.m15.t,EFD.m16.t,EFD.m17.t,EFD.m18.t,EFD.m19.t,EFD.m20.t,EFD.m21.t,EFD.m22.t,EFD.m23.t,EFD.m24.t,EFD.m25.t,EFD.m26.t,EFD.m27.t)
selection.table.EFD.trun <- model.sel(modlist.EFD.trun)
#model 26 best fitting. lets see if it looks any different; Not really.

```


### .3) Using final GLMMs - Generate Predictions & Simulate Error & Plotting

Part A) I will be using the final models created in .1) to generate predictions over the old data set. 
Part B) I will plot these predicted values alongside the raw data to assess model fit.

```{r }

#Might be good to add a new column to the orginal dataframe to assign the predictions to so that I can see exactly what is happening - I think response if the converted value (aka percentage)
EFD.day$Pred.respon <- NA
EFD.day$Pred.link <- NA
EFD.day$Pred.respon <- predict(EFD.m19 , EFD.day, re.form=NA, type="response")
EFD.day$Pred.link  <- predict(EFD.m19 , EFD.day, re.form=NA, type="link")

```
*Note these predictions only generate specific values for each Temperature on each day.* 

#### Part B)
Interpreting and graphing the model predictions.
Note: The predictions provide only 'Population-level' values. Meaning that I only have a single value for each Treatement and on each day.

However, the predictions were generated over a dataset containing individuals, and thus the Temp(X),Day(Y) - specific prediction is repeated Z times for the number of Mosquitoes alive on day Y at temp X. Therefore, it is NOT accurate to create overall temperature averages by simply averaging across each day (unequal # of mosquitoes across each day)

For plotting the predictions I will truncate the dataframe the predictions were stored in to contain only unique combinations of Temperature and Day. 
```{r}
#Create a new dataframe to have only the unique predictions to avoid the aboved noted problem.
EFD.predictions.only <- EFD.day[c("Treatment","Day","Pred.respon","Pred.link","Tscale", "Dscale")]

#Unscale Tscale and Dscale for easy of plotting predicted values;
EFD.predictions.only$Treatment <- EFD.predictions.only$Tscale * attr(EFD.predictions.only$Tscale, 'scaled:scale') + attr(EFD.predictions.only$Tscale, 'scaled:center')

EFD.predictions.only$Day <- as.numeric(EFD.predictions.only$Dscale * attr(EFD.predictions.only$Dscale, 'scaled:scale') + attr(EFD.predictions.only$Dscale, 'scaled:center'))

#Eliminate duplicate values- =
EFD.predictions.test <- distinct(EFD.predictions.only, Treatment, Day ,.keep_all = TRUE)
EFD.predictions.test$Pred.respon <- round(EFD.predictions.test$Pred.respon, 5)

EFD.predictions.test$Treatment <- as.factor(EFD.predictions.test$Treatment)
#Export prediction datafile
#write.csv(EFD.predictions.test, "EFD.GLMM_predictions.csv")

```


Figure: Temp by Day of the predictions
```{r echo = FALSE}
#Plot predictions for each Treatment on each day. ie X = Day, Y = Prediction, Group =Treatment
ggplot(data= EFD.predictions.test, aes(x=Day, y= Pred.respon, colour = Treatment, group = Treatment, linetype = Treatment)) + 
  scale_colour_manual(values= c("#88498F","#1C77C3", "#4C4C4F","#196F0B","#FF6B35","#CC0606")) +
  geom_point(aes( color= Treatment), size = 2, shape = 19) + 
  scale_x_continuous(name="Days at treatment", limits = c (0, 60), breaks = seq(0,60,5), expand = c(0.01,0)) +
  scale_y_continuous(name="Eggs per female", limits=c(0, 30), breaks = seq(0,30,5), expand = c(0.01,0)) +
  theme_bw(base_size = 16) +
  theme(legend.position = c (.75,.9)) +
  guides(col =guide_legend(nrow = 1)) 
#shape = 1 = hollow circle, #shape = 19 = filled circle based on group


```

To add in the raw data to the graph I first have to create a Day-specific average of EFD where the SEM will be determined by the varability betweent the two blocks
```{r}
#Generate day averages of number of eggs on day X over number of females alive on day x, grouped by Treatment 
day.summary <- summarise(group_by(EFD.day, Treatment, Block, Day), EFD.day = mean(EFD), SEM.day = sd(EFD)/sqrt(length(EFD)))
day.summary$Treatment <- as.factor(day.summary$Treatment)

#For the day-specific VC figure I will be calculated the data specific EFD for each block. However 'Block 2' will be REPLICATE #1, 'Blocks 3,5" are REPLICATE #2", Whereas 'Block 4' is the Replicate 3 for the 28C treatment only.
#subsetting the 'raw.bite DF into the above specifications
rep.1.data <- EFD.day[which(EFD.day$Block == 2),]
rep.2.data <- EFD.day[which((EFD.day$Block == 3 | EFD.day$Block == 5)),]
rep.3.data <- EFD.day[which(EFD.day$Block == 4),]

#Calulating the day.summary for bite rate for each replication
rep.1.EFD.sum <- summarise(group_by(rep.1.data, Treatment, Day), EFD.day = mean(EFD), SEM.day = sd(EFD)/sqrt(length(EFD)))
rep.2.EFD.sum <- summarise(group_by(rep.2.data, Treatment, Day), EFD.day = mean(EFD), SEM.day = sd(EFD)/sqrt(length(EFD)))
rep.3.EFD.sum <- summarise(group_by(rep.3.data, Treatment, Day), EFD.day = mean(EFD), SEM.day = sd(EFD)/sqrt(length(EFD)))
#export rep specific EFDdata for use in excel
#write.csv(rep.1.EFD.sum, "rep1.EFD.csv")
#write.csv(rep.2.EFD.sum, "rep2.EFD.csv")
#write.csv(rep.3.EFD.sum, "rep3.EFD.csv")

#Generate replicate-specific averages for EFD with SEM
rep.1.ave.EFD <-  summarise(group_by(rep.1.EFD.sum, Treatment), EFD = mean(EFD.day), SEM = sd(EFD.day)/sqrt(length(EFD.day)))
rep.2.ave.EFD <-  summarise(group_by(rep.2.EFD.sum, Treatment), EFD = mean(EFD.day), SEM = sd(EFD.day)/sqrt(length(EFD.day)))
rep.3.ave.EFD <-  summarise(group_by(rep.3.EFD.sum, Treatment), EFD = mean(EFD.day), SEM = sd(EFD.day)/sqrt(length(EFD.day)))
#Export rep speicifc EFD averages for use in excel
#write.csv(rep.1.ave.EFD, "rep1.ave.EFD.csv")
#write.csv(rep.2.ave.EFD, "rep2.ave.EFD.csv")
#write.csv(rep.3.ave.EFD, "rep3.ave.EFD.csv")


#####
#Note this is generating the SEM of the bite rate between the means of the replicates (n=2)
#####
EFD.day.summary <- summarise(group_by(day.summary, Treatment, Day), EFD2 = mean(EFD.day), SEM = sd(EFD.day)/ sqrt(length(EFD.day)), SD = sd(EFD.day))

EFD.day.summary$Treatment <- as.factor(EFD.day.summary$Treatment)

EFD.treatment.summary <- summarise(group_by(day.summary, Treatment), EFD2 = mean(EFD.day), SEM = sd(EFD.day)/sqrt(length(EFD.day)), SD = sd(EFD.day))

EFD.treatment.summary$Treatment <- as.factor(EFD.treatment.summary$Treatment)

```



```{r }
##Combining raw data with predictions and Temp/ Day values into one dataframe
EFD.all <- merge(EFD.day.summary, EFD.predictions.test, by = c("Treatment", "Day"))


EFD.all$Treatment <- as.factor(EFD.all$Treatment)
#write out this csv to be used in the final figure code
#write.csv(EFD.all, "merged.EFD.day.data.csv")

###Figure 1b. figure aspects
#1. block specific day values for daily egg production (points)
#2. day specific values for daily egg production (faded lines)
#3. best fitting glm model predictions for daily egg production (lines)

EFD.day.summary$Treatment <- as.factor(EFD.day.summary$Treatment)

egg.day.plot <- ggplot(data= day.summary, aes(x=Day, colour = factor(Treatment), group = factor(Treatment))) + 
        scale_colour_manual(values= c("#88498F","#1C77C3", "#4C4C4F","#196F0B","#FF6B35","#CC0606")) +
        scale_fill_manual(values= c("#88498F","#1C77C3", "#4C4C4F","#196F0B","#FF6B35","#CC0606")) +
        geom_point(aes(y = EFD.day), shape = 16, size = 1.5, alpha = .6, stroke =1.2, fill = NA) + 
        scale_x_continuous(name="Days at temperature", limits = c (0, 60), breaks = seq(0,60,10), expand = c(0.02,0.02)) +
         scale_y_continuous(name="Daily egg production", limits=c(0, 37.4), breaks = seq(0,36,10), expand = c(0.02,0.02)) +
           # geom_line(data = subset(EFD.all[EFD.all$Day >2,]), aes(y = Pred.respon), linetype = "solid", size = 1.5 ) +    #truncated dataset
        geom_line(data = EFD.all, aes(y = Pred.respon), linetype = "solid", size = 1.5 ) +    #truncated dataset
        theme_classic(base_size = 20) +
        geom_line(data = EFD.day.summary, aes( y= EFD2), linetype = "solid", size = 1.2, alpha = 0.4) +
        theme_classic( base_size = 20) +
        theme(legend.position = 'none', panel.border = element_rect(colour = "black", fill=NA, size=.5),  panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), panel.background = element_blank(), strip.background = element_blank(), strip.text = element_blank())

plot(egg.day.plot)

egg.day.plot + facet_grid(Treatment ~ .)

```


Placing Day Plots into a final Figure
```{r}
library(ggpubr)

bite.day.plot2 <- bite.day.plot + facet_grid(Treatment ~ .) +
      theme(legend.position = "bottom" ,legend.direction = "horizontal")+
      guides(colour = guide_legend(nrow = 1)) 

egg.day.plot2 <- egg.day.plot + facet_grid(Treatment ~ .) +
      theme(legend.position = "bottom" ,legend.direction = "horizontal")+
      guides(colour = guide_legend(nrow = 1)) 



figure2part1 <- ggarrange(bite.day.plot2, egg.day.plot2, ncol = 2, labels = c("a", "b"),font.label = list(size =20),common.legend = TRUE, legend = "none")
plot(figure2part1)

#ggsave("figure2part1_revised.fullmodels.png", figure2part1, path = NULL, scale = 1, width = 8, height = 7, device = 'png', dpi = 500)

figure1part1a.reviewer <- ggarrange(bite.GLMM.reviewer2, NULL, ncol = 2, labels = c("a"),font.label = list(size =20),common.legend = TRUE, legend = "none")
plot(figure1part1a.reviewer)

#ggsave("figure1parta_reviewer2.png", figure1part1a.reviewer, path = NULL, scale = 1, width = 8, height = 7, device = 'png', dpi = 500)
```
